/**
 * @file crc16_koopman.c
 * @brief CRC-16 implementation using Koopman polynomial (0x8D95)
 */
#include "crc16_koopman.h"
#include <zephyr/logging/log.h>

LOG_MODULE_REGISTER(crc16_koopman, LOG_LEVEL_INF);

/* Koopman polynomial: 0x8D95 (0x9EB2 with reversed bits) */
#define CRC16_KOOPMAN_POLY 0x8D95

/* Precomputed CRC-16 lookup table for faster calculation */
static const uint16_t crc16_koopman_table[256] = {
    0x0000, 0x8D95, 0x9EB2, 0x1327, 0xAD45, 0x20D0, 0x33F7, 0xBE62,
    0xC9CE, 0x445B, 0x577C, 0xDAE9, 0x648B, 0xE91E, 0xFA39, 0x77AC,
    0x5275, 0xDFE0, 0xCCC7, 0x4152, 0xFF30, 0x72A5, 0x6182, 0xEC17,
    0x9BBB, 0x162E, 0x0509, 0x889C, 0x36FE, 0xBB6B, 0xA84C, 0x25D9,
    0xA4EA, 0x297F, 0x3A58, 0xB7CD, 0x09AF, 0x843A, 0x971D, 0x1A88,
    0x6D24, 0xE0B1, 0xF396, 0x7E03, 0xC061, 0x4DF4, 0x5ED3, 0xD346,
    0xF69F, 0x7B0A, 0x682D, 0xE5B8, 0x5BDA, 0xD64F, 0xC568, 0x48FD,
    0x3F51, 0xB2C4, 0xA1E3, 0x2C76, 0x9214, 0x1F81, 0x0CA6, 0x8133,
    0xC9B7, 0x4422, 0x5705, 0xDA90, 0x64F2, 0xE967, 0xFA40, 0x77D5,
    0x0079, 0x8DEC, 0x9ECB, 0x135E, 0xAD3C, 0x20A9, 0x338E, 0xBE1B,
    0x9BC2, 0x1657, 0x0570, 0x88E5, 0x3687, 0xBB12, 0xA835, 0x25A0,
    0x520C, 0xDF99, 0xCCBE, 0x412B, 0xFF49, 0x72DC, 0x61FB, 0xEC6E,
    0x6D5D, 0xE0C8, 0xF3EF, 0x7E7A, 0xC018, 0x4D8D, 0x5EAA, 0xD33F,
    0xA493, 0x2906, 0x3A21, 0xB7B4, 0x09D6, 0x8443, 0x9764, 0x1AF1,
    0x3F28, 0xB2BD, 0xA19A, 0x2C0F, 0x926D, 0x1FF8, 0x0CDF, 0x814A,
    0xF6E6, 0x7B73, 0x6854, 0xE5C1, 0x5BA3, 0xD636, 0xC511, 0x4884,
    0x53FD, 0xDE68, 0xCD4F, 0x40DA, 0xFEB8, 0x732D, 0x600A, 0xED9F,
    0x9A33, 0x17A6, 0x0481, 0x8914, 0x3776, 0xBAE3, 0xA9C4, 0x2451,
    0x0188, 0x8C1D, 0x9F3A, 0x12AF, 0xACCD, 0x2158, 0x327F, 0xBFEA,
    0xC846, 0x45D3, 0x56F4, 0xDB61, 0x6503, 0xE896, 0xFBB1, 0x7624,
    0xF717, 0x7A82, 0x69A5, 0xE430, 0x5A52, 0xD7C7, 0xC4E0, 0x4975,
    0x3ED9, 0xB34C, 0xA06B, 0x2DFE, 0x939C, 0x1E09, 0x0D2E, 0x80BB,
    0xA562, 0x28F7, 0x3BD0, 0xB645, 0x0827, 0x85B2, 0x9695, 0x1B00,
    0x6CAC, 0xE139, 0xF21E, 0x7F8B, 0xC1E9, 0x4C7C, 0x5F5B, 0xD2CE,
    0x9A4A, 0x17DF, 0x04F8, 0x896D, 0x370F, 0xBA9A, 0xA9BD, 0x2428,
    0x5384, 0xDE11, 0xCD36, 0x40A3, 0xFEC1, 0x7354, 0x6073, 0xEDE6,
    0xC83F, 0x45AA, 0x568D, 0xDB18, 0x657A, 0xE8EF, 0xFBC8, 0x765D,
    0x01F1, 0x8C64, 0x9F43, 0x12D6, 0xACB4, 0x2121, 0x3206, 0xBF93,
    0x3EA0, 0xB335, 0xA012, 0x2D87, 0x93E5, 0x1E70, 0x0D57, 0x80C2,
    0xF76E, 0x7AFB, 0x69DC, 0xE449, 0x5A2B, 0xD7BE, 0xC499, 0x490C,
    0x6CD5, 0xE140, 0xF267, 0x7FF2, 0xC190, 0x4C05, 0x5F22, 0xD2B7,
    0xA51B, 0x288E, 0x3BA9, 0xB63C, 0x085E, 0x85CB, 0x96EC, 0x1B79
};

/**
 * @brief Calculate CRC-16 using Koopman polynomial 0x8D95
 * 
 * @param data Pointer to the data buffer
 * @param length Length of the data buffer in bytes
 * @return Calculated CRC-16 value
 */
uint16_t crc16_koopman(const uint8_t *data, size_t length) {
    /* Start with initial CRC value of 0 */
    return crc16_koopman_update(0, data, length);
}

/**
 * @brief Update an existing CRC-16 with new data
 * 
 * This function uses a table-based approach for faster CRC calculation.
 * 
 * @param crc Initial CRC value (use 0 for first call)
 * @param data Pointer to the data buffer
 * @param length Length of the data buffer in bytes
 * @return Updated CRC-16 value
 */
uint16_t crc16_koopman_update(uint16_t crc, const uint8_t *data, size_t length) {
    size_t i;
    
    /* Validate input parameters */
    if (data == NULL && length > 0) {
        LOG_ERR("Invalid input: NULL data pointer with non-zero length");
        return crc;
    }

    /* Calculate CRC for each byte using table lookup */
    for (i = 0; i < length; i++) {
        crc = (crc << 8) ^ crc16_koopman_table[(crc >> 8) ^ data[i]];
    }

    return crc;
}

/* Non-table implementation for reference */
uint16_t crc16_koopman_bit_by_bit(const uint8_t *data, size_t length) {
    uint16_t crc = 0;
    size_t i, j;

    for (i = 0; i < length; i++) {
        crc ^= (data[i] << 8);
        for (j = 0; j < 8; j++) {
            if (crc & 0x8000) {
                crc = (crc << 1) ^ CRC16_KOOPMAN_POLY;
            } else {
                crc = crc << 1;
            }
        }
    }
    
    return crc;
}